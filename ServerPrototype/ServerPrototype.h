#pragma once
///////////////////////////////////////////////////////////////////////////////
// ServerPrototype.h - Console App that processes incoming messages			 //
// ver 1.0																	 //
// Source: Jim Fawcett, CSE687 - Object Oriented Design, Spring 2018         //
// Author: Vishnu Karthik Ravindran, Spring 2018, OOD, Project 3             //
///////////////////////////////////////////////////////////////////////////////
/*
*  Package Operations:
* ---------------------
*  Package contains one class, Server, that contains a Message-Passing Communication
*  facility. It processes each message by invoking an installed callable object
*  defined by the message's command key.
*
*  Message handling runs on a child thread, so the Server main thread is free to do
*  any necessary background processing (none, so far).
*
*  Required Files:
* -----------------
*  ServerPrototype.h, ServerPrototype.cpp
*  Comm.h, Comm.cpp, IComm.h
*  Message.h, Message.cpp
*  FileSystem.h, FileSystem.cpp
*  Utilities.h
*
*  Maintenance History:
* ----------------------
*  ver 1.0 : 3/27/2018
*  - first release
*  ver 2.0 : 4/10/2018
*  - Added check-in, check-out, browsing, connect lambda expressions
*    to be invoked using the command received from Client
*/
#include <vector>
#include <string>
#include <unordered_map>
#include <functional>
#include <thread>
#include "../CppCommWithFileXfer/Message/Message.h"
#include "../CppCommWithFileXfer/MsgPassingComm/Comm.h"
#include <windows.h>
#include <tchar.h>

//----< Respository Namespace for Project-3 >-------------
/*
*  This namespace contains the necessary functions to create
*  communication channel for the server. It also contains the thread
*  which are used for running the functions in the dispatcher
*  on receiving command from client. Dispatcher used in the server
*  is created in this namespace.
*/
namespace Repository
{
	/////////////////////////////////////////////////////////////////////////
	// Alias names used in this class
	using File = std::string;
	using Files = std::vector<File>;
	using Dir = std::string;
	using Dirs = std::vector<Dir>;
	using SearchPath = std::string;
	using DBFilePath = std::string;
	using Key = std::string;
	using Msg = MsgPassingCommunication::Message;
	using ServerProc = std::function<Msg(Msg)>;
	using MsgDispatcher = std::unordered_map<Key, ServerProc>;

	const SearchPath storageRoot = "../ServerStorage";  // Root path for server file storage
	const DBFilePath repXMLFilePath = "../ServerStorage/NoSqlDbFile.xml";
	const MsgPassingCommunication::EndPoint serverEndPoint("localhost", 8080);  // Listening endpoint

	//----< Server class >-------------
	/*
	*  This class contains functions to start, stop
	*  and create dispatcher for the server used in the
	*  server-client communication.
	*/
	class Server
	{
	public:
		/////////////////////////////////////////////////////////////////////////
		// Constructor of Server class whose arguments are the server endpoint,
		// name of the server, send and save file path to store the 
		// file while transfer
		Server(MsgPassingCommunication::EndPoint ep, const std::string& name);

		/////////////////////////////////////////////////////////////////////////
		// Starts the communication channel. Creates sender and receiver threads
		// listening to the socket assigned to the connection
		void start();

		/////////////////////////////////////////////////////////////////////////
		// Stops the communication channel. This passes quit message to the 
		// sender and receiver thread. It also shutsdown the socket.
		void stop();

		/////////////////////////////////////////////////////////////////////////
		// Adds the server procedure function reference to the
		// to the dispatcher
		void addMsgProc(Key key, ServerProc proc);

		/////////////////////////////////////////////////////////////////////////
		// This method contains the thread which executes on the server with
		// message received from the client
		void processMessages();

		/////////////////////////////////////////////////////////////////////////
		// This method posts the reply message generated by the 
		// server procedures
		void postMessage(MsgPassingCommunication::Message msg);

		/////////////////////////////////////////////////////////////////////////
		// This method is used for getting the message from the client by
		// the server received through socket
		MsgPassingCommunication::Message getMessage();

		/////////////////////////////////////////////////////////////////////////
		// Used to get the directories in the server based on the path
		// send to the server from client
		static Dirs getDirs(const SearchPath& path = storageRoot);

		/////////////////////////////////////////////////////////////////////////
		// Used to get the files in the server based on the path
		// send to the server from client
		static Files getFiles(const SearchPath& path = storageRoot);

		/////////////////////////////////////////////////////////////////////////
		// Used to get the path context from the server
		MsgPassingCommunication::Context* getContext();

		/////////////////////////////////////////////////////////////////////////
		// Used to set the send file path in the server for the
		// communication channel
		std::string setSendFilePath(const std::string& relPath);

		/////////////////////////////////////////////////////////////////////////
		// Used to set the files in the server for the
		// communication channel
		std::string setSaveFilePath(const std::string& relPath);

		/////////////////////////////////////////////////////////////////////////
		// Used to get the send file path from the server 
		// from the comm channel
		std::string getSendFilePath();

		/////////////////////////////////////////////////////////////////////////
		// Used to get the files in the server based on the path
		// from the comm channel
		std::string getSaveFilePath();

		/////////////////////////////////////////////////////////////////////////
		// Used to get the file path from the comm channel
		static void fileCopy(const std::string& sourceFilePath, const std::string& destinationFilePath);

		/////////////////////////////////////////////////////////////////////////
		// This function holds the dummy dependent values in server.
		// This will be changed later in project-4 after integartion with NoSql Db
		static std::vector<std::string> getDependents() { return std::vector<std::string>{"Child1", "Child2", "Child3"}; };

		/////////////////////////////////////////////////////////////////////////
		// This function holds the dummy categories values in server.
		// This will be changed later in project-4 after integartion with NoSql Db
		static std::vector<std::string> getCategories() { return std::vector<std::string>{"Dummy Category1", "Dummy Category2", "Dummy Category3"}; };

		/////////////////////////////////////////////////////////////////////////
		// This function holds the dummy description values in server.
		// This will be changed later in project-4 after integartion with NoSql Db
		static std::string getDescription() { return "Dummy Description"; };
	private:
		/////////////////////////////////////////////////////////////////////////
		// Instance of the communicqation channel in server
		MsgPassingCommunication::Comm comm_;

		/////////////////////////////////////////////////////////////////////////
		// Dispatcher in the server side holding function references
		MsgDispatcher dispatcher_;

		/////////////////////////////////////////////////////////////////////////
		// Thread running whihc exceutes functions based on the command from
		// client
		std::thread msgProcThrd_;
	};

	/////////////////////////////////////////////////////////////////////////
	// Constructor of Server class whose arguments are the server endpoint,
	// name of the server, send and save file path to store the 
	// file while transfer
	inline Server::Server(MsgPassingCommunication::EndPoint ep, const std::string& name)
		: comm_(ep, name) {

	}

	/////////////////////////////////////////////////////////////////////////
	// Starts the communication channel. Creates sender and receiver threads
	// listening to the socket assigned to the connection
	inline void Server::start()
	{
		comm_.start();
	}

	/////////////////////////////////////////////////////////////////////////
	// Stops the communication channel. This passes quit message to the 
	// sender and receiver thread. It also shutsdown the socket.
	inline void Server::stop()
	{
		if (msgProcThrd_.joinable())
			msgProcThrd_.join();
		comm_.stop();
	}

	/////////////////////////////////////////////////////////////////////////
	// Used to get the path context from the server
	inline MsgPassingCommunication::Context* Server::getContext()
	{
		return comm_.getContext();
	}

	/////////////////////////////////////////////////////////////////////////
	// Used to set the send file path in the server for the
	// communication channel
	inline std::string Server::setSendFilePath(const std::string& relPath)
	{
		comm_.setSendFilePath(relPath);
	}

	/////////////////////////////////////////////////////////////////////////
	// Used to set the files in the server for the
	// communication channel
	inline std::string Server::setSaveFilePath(const std::string& relPath)
	{
		comm_.setSaveFilePath(relPath);
	}

	/////////////////////////////////////////////////////////////////////////
	// Used to get the send file path from the server 
	// from the comm channel
	inline std::string Server::getSendFilePath()
	{
		comm_.getSendFilePath();
	}

	/////////////////////////////////////////////////////////////////////////
	// Used to get the files in the server based on the path
	// from the comm channel
	inline std::string Server::getSaveFilePath()
	{
		comm_.getSaveFilePath();
	}

	/////////////////////////////////////////////////////////////////////////
	// This method posts the reply message generated by the 
	// server procedures
	inline void Server::postMessage(MsgPassingCommunication::Message msg)
	{
		comm_.postMessage(msg);
	}

	/////////////////////////////////////////////////////////////////////////
	// This method is used for getting the message from the client by
	// the server received through socket and get message from Comm 
	inline MsgPassingCommunication::Message Server::getMessage()
	{
		Msg msg = comm_.getMessage();
		return msg;
	}

	/////////////////////////////////////////////////////////////////////////
	// Adds the server procedure function reference to the
	// to the dispatcher. Adds ServerProc callable object to server's dispatcher
	inline void Server::addMsgProc(Key key, ServerProc proc)
	{
		dispatcher_[key] = proc;
	}

	//----< start processing messages on child thread >------------------
	inline void Server::processMessages()
	{
		auto proc = [&]()
		{
			if (dispatcher_.size() == 0)
			{
				std::cout << "\n  No server procedures to call.";
				return;
			}
			while (true)
			{
				try
				{
					Msg msg = getMessage();
					if (msg.attributes().size() == 0)
						continue;
					std::cout << "\n\n  ********Received command: \"" << msg.command() << "\" from \"" << msg.from().toString() + "\"*********";
					if (msg.containsKey("verbose"))
					{
						std::cout << "\n";
						msg.show();
					}
					if (msg.command() == "serverQuit")
						break;
					std::cout << "\n\n  Incoming Message from Client";
					msg.show();
					std::this_thread::sleep_for(std::chrono::milliseconds(50));
					if (msg.value("command") == "oneway")
						continue;
					Msg reply = dispatcher_[msg.command()](msg);
					if (msg.to().port != msg.from().port)  // avoid infinite message loop
					{
						reply.attribute("testMsg", msg.value("testMsg"));
						postMessage(reply);
					}
					else
						std::cout << "\n  server attempting to post to self";
				}
				catch (std::exception e)
				{
					continue;
				}
			}
			std::cout << "\n  Server message processing thread is shutting down";
		};
		std::thread t(proc);
		std::cout << "\n  Starting server thread to process messages using commands sent by the client";
		msgProcThrd_ = std::move(t);
	}
}